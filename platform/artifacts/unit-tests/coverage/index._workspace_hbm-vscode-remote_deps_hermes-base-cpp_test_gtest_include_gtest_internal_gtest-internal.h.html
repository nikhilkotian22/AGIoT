
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Head</title>
  <style media="screen" type="text/css">
  
    body
    {
      color: #000000;
      background-color: #FFFFFF;
    }

    /* Link formats: use maroon w/underlines */
    a:link
    {
      color: navy;
      text-decoration: underline;
    }
    a:visited
    {
      color: maroon;
      text-decoration: underline;
    }
    a:active
    {
      color: navy;
      text-decoration: underline;
    }
    
    /*** TD formats ***/
    td
    {
      font-family: sans-serif;
    }
    td.title
    {
      text-align: center;
      padding-bottom: 10px;
      font-size: 20pt;
      font-weight: bold;
    }
    
    /* TD Header Information */
    td.headerName
    {
      text-align: right;
      color: black;
      padding-right: 6px;
      font-weight: bold;
      vertical-align: top;
      white-space: nowrap;
    }
    td.headerValue
    {
      text-align: left;
      color: blue;
      font-weight: bold;
      white-space: nowrap;
    }
    td.headerTableEntry
    {
      text-align: right;
      color: black;
      font-weight: bold;
      white-space: nowrap;
      padding-left: 12px;
      padding-right: 4px;
      background-color: LightBlue;
    }
    td.headerValueLeg
    {
      text-align: left;
      color: black;
      font-size: 80%;
      white-space: nowrap;
      padding-left: 10px;
      padding-right: 10px;
      padding-top: 2px;
    }
    
    /* Color of horizontal ruler */
    td.hr
    {
      background-color: navy;
      height:3px;
    }
    /* Footer format */
    td.footer
    {
      text-align: center;
      padding-top: 3px;
      font-family: sans-serif;
    }

    /* Coverage Table */    

    td.coverTableHead
    {
      text-align: center;
      color: white;
      background-color: SteelBlue;
      font-family: sans-serif;
      font-size: 120%;
      white-space: nowrap;
      padding-left: 4px;
      padding-right: 4px;
    }
    td.coverFile
    {
      text-align: left;
      padding-left: 10px;
      padding-right: 20px; 
      color: black;
      background-color: LightBlue;
      font-family: monospace;
      font-weight: bold;
      font-size: 110%;
    }
    td.coverBar
    {
      padding-left: 10px;
      padding-right: 10px;
      background-color: LightBlue;
    }
    td.coverBarOutline
    {
      background-color: white;
    }
    td.coverValue
    {
      padding-top: 2px;
      text-align: right;
      padding-left: 10px;
      padding-right: 10px;
      font-family: sans-serif;
      white-space: nowrap;
      font-weight: bold;
    }
    
    /* Link Details */
    a.detail:link
    {
      color: #B8D0FF;
      font-size:80%;
    }
    a.detail:visited
    {
      color: #B8D0FF;
      font-size:80%;
    }
    a.detail:active
    {
      color: #FFFFFF;
      font-size:80%;
    }
    
    .graphcont{
        color:#000;
        font-weight:700;
        float:left
    }

    .graph{
        float:left;
        background-color: white;
        position:relative;
        width:280px;
        padding:0
    }

    .graph .bar{
        display:block;
        position:relative;
        border:black 1px solid;
        text-align:center;
        color:#fff;
        height:10px;
        font-family:Arial,Helvetica,sans-serif;
        font-size:12px;
        line-height:1.9em
    }

    .graph .bar span{
        position:absolute;
        left:1em
    } 

    td.coveredLine,
    span.coveredLine
    {
        background-color: LightGreen!important;
    }

    td.uncoveredLine,
    span.uncoveredLine
    {
        background-color: LightPink!important;
    }

    .linecount
    {
        border-right: 1px gray solid;
        background-color: lightgray;
    }

    .src 
    {
        padding-left: 12px;
    }

    .srcHeader
    {
        font-family: monospace; 
        font-weight: bold;
    }

    pre 
    {
        height : 15px;
        margin-top: 0;
        margin-bottom: 0;
    }

    .lineno
    {
        background-color: #EFE383;
        border-right: 1px solid #BBB15F;
    }

  </style>
</head>

<body>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr><td class="title">GCC Code Coverage Report</td></tr>
    <tr><td class="hr"></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding="1" border="0" width="100%">
          <tr>
            <td width="10%" class="headerName">Directory:</td>
            <td width="35%" class="headerValue">/</td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerValue" style="text-align:right;">Exec</td>
            <td width="10%" class="headerValue" style="text-align:right;">Total</td>
            <td width="15%" class="headerValue" style="text-align:right;">Coverage</td>
          </tr>
          <tr>
            <td class="headerName">File:</td>
            <td class="headerValue">/workspace/hbm-vscode-remote/deps/hermes-base-cpp/test/gtest/include/gtest/internal/gtest-internal.h</td>
            <td></td>
            <td class="headerName">Lines:</td>
            <td class="headerTableEntry">8</td>
            <td class="headerTableEntry">9</td>
            <td class="headerTableEntry" style="background-color:#FFFF55">88.9 %</td>
          </tr>
          <tr>
            <td class="headerName">Date:</td>
            <td class="headerValue">2020-09-13</td>
            <td></td>
            <td class="headerName">Branches:</td>
            <td class="headerTableEntry">1</td>
            <td class="headerTableEntry">6</td>
            <td class="headerTableEntry" style="background-color:LightPink">16.7 %</td>
          </tr>
        </table>
      </td>
    </tr>

    <tr><td class="hr"></td></tr>
  </table>

  <br>
  <table cellspacing="0" cellpadding="1">
    <tr>
      <td width="5%" align="right" class="srcHeader">Line</td>
      <td width="10%" align="right" class="srcHeader">Exec</td>
      <td width="75%" align="left" class="srcHeader src">Source</td>
    </tr>

    
    <tr>
    <td align="right" class="lineno"><pre>1</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Copyright 2005, Google Inc.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>2</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// All rights reserved.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>3</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>4</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Redistribution and use in source and binary forms, with or without</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>5</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// modification, are permitted provided that the following conditions are</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>6</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// met:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>7</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>8</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//     * Redistributions of source code must retain the above copyright</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>9</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// notice, this list of conditions and the following disclaimer.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>10</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//     * Redistributions in binary form must reproduce the above</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>11</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// copyright notice, this list of conditions and the following disclaimer</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>12</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// in the documentation and/or other materials provided with the</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>13</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// distribution.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>14</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//     * Neither the name of Google Inc. nor the names of its</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>15</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// contributors may be used to endorse or promote products derived from</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>16</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// this software without specific prior written permission.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>17</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>18</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>19</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>20</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>21</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>22</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>23</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>24</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>25</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>26</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>27</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>28</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>29</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>30</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>31</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// The Google C++ Testing Framework (Google Test)</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>32</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>33</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// This header file declares functions and macros used internally by</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>34</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Google Test.  They are subject to change without notice.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>35</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>36</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>37</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>38</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>39</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#include "gtest/internal/gtest-port.h"</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>40</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>41</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#if GTEST_OS_LINUX</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>42</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre># include &lt;stdlib.h&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>43</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre># include &lt;sys/types.h&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>44</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre># include &lt;sys/wait.h&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>45</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre># include &lt;unistd.h&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>46</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#endif  // GTEST_OS_LINUX</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>47</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>48</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#if GTEST_HAS_EXCEPTIONS</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>49</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre># include &lt;stdexcept&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>50</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#endif</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>51</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>52</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#include &lt;ctype.h&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>53</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#include &lt;float.h&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>54</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#include &lt;string.h&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>55</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#include &lt;iomanip&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>56</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#include &lt;limits&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>57</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#include &lt;map&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>58</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#include &lt;set&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>59</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#include &lt;string&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>60</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#include &lt;vector&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>61</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>62</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#include "gtest/gtest-message.h"</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>63</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#include "gtest/internal/gtest-filepath.h"</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>64</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#include "gtest/internal/gtest-string.h"</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>65</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#include "gtest/internal/gtest-type-util.h"</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>66</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>67</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Due to C++ preprocessor weirdness, we need double indirection to</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>68</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// concatenate two tokens when one of them is __LINE__.  Writing</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>69</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>70</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//   foo ## __LINE__</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>71</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>72</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// will result in the token foo__LINE__, instead of foo followed by</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>73</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// the current line number.  For more details, see</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>74</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// http://www.parashift.com/c++-faq-lite/misc-technical-issues.html#faq-39.6</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>75</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#define GTEST_CONCAT_TOKEN_(foo, bar) GTEST_CONCAT_TOKEN_IMPL_(foo, bar)</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>76</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#define GTEST_CONCAT_TOKEN_IMPL_(foo, bar) foo ## bar</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>77</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>78</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>class ProtocolMessage;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>79</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>namespace proto2 { class Message; }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>80</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>81</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>namespace testing {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>82</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>83</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Forward declarations.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>84</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>85</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>class AssertionResult;                 // Result of an assertion.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>86</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>class Message;                         // Represents a failure message.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>87</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>class Test;                            // Represents a test.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>88</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>class TestInfo;                        // Information about a test.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>89</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>class TestPartResult;                  // Result of a test part.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>90</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>class UnitTest;                        // A collection of test cases.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>91</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>92</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename T&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>93</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>::std::string PrintToString(const T&amp; value);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>94</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>95</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>namespace internal {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>96</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>97</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>struct TraceInfo;                      // Information about a trace point.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>98</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>class TestInfoImpl;                    // Opaque implementation of TestInfo</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>99</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>class UnitTestImpl;                    // Opaque implementation of UnitTest</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>100</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>101</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// The text used in failure messages to indicate the start of the</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>102</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// stack trace.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>103</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>GTEST_API_ extern const char kStackTraceMarker[];</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>104</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>105</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Two overloaded helpers for checking at compile time whether an</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>106</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// expression is a null pointer literal (i.e. NULL or any 0-valued</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>107</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// compile-time integral constant).  Their return values have</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>108</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// different sizes, so we can use sizeof() to test which version is</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>109</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// picked by the compiler.  These helpers have no implementations, as</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>110</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// we only need their signatures.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>111</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>112</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Given IsNullLiteralHelper(x), the compiler will pick the first</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>113</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// version if x can be implicitly converted to Secret*, and pick the</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>114</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// second version otherwise.  Since Secret is a secret and incomplete</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>115</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// type, the only expression a user can write that has type Secret* is</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>116</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// a null pointer literal.  Therefore, we know that x is a null</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>117</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// pointer literal if and only if the first version is picked by the</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>118</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// compiler.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>119</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>char IsNullLiteralHelper(Secret* p);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>120</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>char (&amp;IsNullLiteralHelper(...))[2];  // NOLINT</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>121</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>122</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// A compile-time bool constant that is true if and only if x is a</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>123</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// null pointer literal (i.e. NULL or any 0-valued compile-time</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>124</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// integral constant).</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>125</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#ifdef GTEST_ELLIPSIS_NEEDS_POD_</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>126</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// We lose support for NULL detection where the compiler doesn't like</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>127</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// passing non-POD classes through ellipsis (...).</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>128</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre># define GTEST_IS_NULL_LITERAL_(x) false</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>129</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#else</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>130</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre># define GTEST_IS_NULL_LITERAL_(x) \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>131</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    (sizeof(::testing::internal::IsNullLiteralHelper(x)) == 1)</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>132</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#endif  // GTEST_ELLIPSIS_NEEDS_POD_</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>133</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>134</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Appends the user-supplied message to the Google-Test-generated message.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>135</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>GTEST_API_ std::string AppendUserMessage(</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>136</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    const std::string&amp; gtest_msg, const Message&amp; user_msg);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>137</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>138</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#if GTEST_HAS_EXCEPTIONS</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>139</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>140</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// This exception is thrown by (and only by) a failed Google Test</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>141</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// assertion when GTEST_FLAG(throw_on_failure) is true (if exceptions</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>142</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// are enabled).  We derive it from std::runtime_error, which is for</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>143</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// errors presumably detectable only at run time.  Since</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>144</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// std::runtime_error inherits from std::exception, many testing</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>145</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// frameworks know how to extract and print the message inside it.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>146</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>class GTEST_API_ GoogleTestFailureException : public ::std::runtime_error {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>147</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre> public:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>148</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  explicit GoogleTestFailureException(const TestPartResult&amp; failure);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>149</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>};</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>150</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>151</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#endif  // GTEST_HAS_EXCEPTIONS</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>152</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>153</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>namespace edit_distance {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>154</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Returns the optimal edits to go from 'left' to 'right'.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>155</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// All edits cost the same, with replace having lower priority than</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>156</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// add/remove.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>157</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Simple implementation of the Wagner–Fischer algorithm.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>158</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// See http://en.wikipedia.org/wiki/Wagner-Fischer_algorithm</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>159</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>enum EditType { kMatch, kAdd, kRemove, kReplace };</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>160</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>GTEST_API_ std::vector&lt;EditType&gt; CalculateOptimalEdits(</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>161</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    const std::vector&lt;size_t&gt;&amp; left, const std::vector&lt;size_t&gt;&amp; right);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>162</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>163</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Same as above, but the input is represented as strings.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>164</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>GTEST_API_ std::vector&lt;EditType&gt; CalculateOptimalEdits(</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>165</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    const std::vector&lt;std::string&gt;&amp; left,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>166</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    const std::vector&lt;std::string&gt;&amp; right);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>167</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>168</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Create a diff of the input strings in Unified diff format.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>169</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>GTEST_API_ std::string CreateUnifiedDiff(const std::vector&lt;std::string&gt;&amp; left,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>170</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                                         const std::vector&lt;std::string&gt;&amp; right,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>171</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                                         size_t context = 2);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>172</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>173</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>}  // namespace edit_distance</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>174</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>175</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Calculate the diff between 'left' and 'right' and return it in unified diff</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>176</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// format.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>177</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// If not null, stores in 'total_line_count' the total number of lines found</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>178</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// in left + right.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>179</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>GTEST_API_ std::string DiffStrings(const std::string&amp; left,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>180</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                                   const std::string&amp; right,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>181</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                                   size_t* total_line_count);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>182</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>183</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Constructs and returns the message for an equality assertion</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>184</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// (e.g. ASSERT_EQ, EXPECT_STREQ, etc) failure.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>185</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>186</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// The first four parameters are the expressions used in the assertion</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>187</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// and their values, as strings.  For example, for ASSERT_EQ(foo, bar)</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>188</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// where foo is 5 and bar is 6, we have:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>189</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>190</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//   expected_expression: "foo"</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>191</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//   actual_expression:   "bar"</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>192</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//   expected_value:      "5"</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>193</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//   actual_value:        "6"</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>194</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>195</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// The ignoring_case parameter is true iff the assertion is a</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>196</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// *_STRCASEEQ*.  When it's true, the string " (ignoring case)" will</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>197</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// be inserted into the message.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>198</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>GTEST_API_ AssertionResult EqFailure(const char* expected_expression,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>199</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                                     const char* actual_expression,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>200</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                                     const std::string&amp; expected_value,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>201</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                                     const std::string&amp; actual_value,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>202</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                                     bool ignoring_case);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>203</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>204</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Constructs a failure message for Boolean assertions such as EXPECT_TRUE.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>205</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>GTEST_API_ std::string GetBoolAssertionFailureMessage(</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>206</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    const AssertionResult&amp; assertion_result,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>207</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    const char* expression_text,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>208</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    const char* actual_predicate_value,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>209</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    const char* expected_predicate_value);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>210</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>211</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// This template class represents an IEEE floating-point number</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>212</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// (either single-precision or double-precision, depending on the</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>213</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// template parameters).</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>214</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>215</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// The purpose of this class is to do more sophisticated number</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>216</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// comparison.  (Due to round-off error, etc, it's very unlikely that</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>217</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// two floating-points will be equal exactly.  Hence a naive</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>218</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// comparison by the == operation often doesn't work.)</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>219</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>220</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Format of IEEE floating-point:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>221</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>222</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//   The most-significant bit being the leftmost, an IEEE</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>223</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//   floating-point looks like</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>224</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>225</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//     sign_bit exponent_bits fraction_bits</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>226</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>227</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//   Here, sign_bit is a single bit that designates the sign of the</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>228</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//   number.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>229</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>230</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//   For float, there are 8 exponent bits and 23 fraction bits.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>231</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>232</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//   For double, there are 11 exponent bits and 52 fraction bits.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>233</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>234</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//   More details can be found at</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>235</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//   http://en.wikipedia.org/wiki/IEEE_floating-point_standard.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>236</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>237</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Template parameter:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>238</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>239</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//   RawType: the raw floating-point type (either float or double)</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>240</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename RawType&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>241</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>class FloatingPoint {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>242</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre> public:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>243</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Defines the unsigned integer type that has the same size as the</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>244</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // floating point number.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>245</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  typedef typename TypeWithSize&lt;sizeof(RawType)&gt;::UInt Bits;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>246</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>247</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Constants.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>248</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>249</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // # of bits in a number.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>250</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  static const size_t kBitCount = 8*sizeof(RawType);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>251</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>252</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // # of fraction bits in a number.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>253</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  static const size_t kFractionBitCount =</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>254</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    std::numeric_limits&lt;RawType&gt;::digits - 1;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>255</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>256</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // # of exponent bits in a number.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>257</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  static const size_t kExponentBitCount = kBitCount - 1 - kFractionBitCount;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>258</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>259</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // The mask for the sign bit.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>260</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  static const Bits kSignBitMask = static_cast&lt;Bits&gt;(1) &lt;&lt; (kBitCount - 1);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>261</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>262</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // The mask for the fraction bits.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>263</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  static const Bits kFractionBitMask =</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>264</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    ~static_cast&lt;Bits&gt;(0) &gt;&gt; (kExponentBitCount + 1);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>265</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>266</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // The mask for the exponent bits.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>267</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  static const Bits kExponentBitMask = ~(kSignBitMask | kFractionBitMask);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>268</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>269</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // How many ULP's (Units in the Last Place) we want to tolerate when</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>270</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // comparing two numbers.  The larger the value, the more error we</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>271</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // allow.  A 0 value means that two numbers must be exactly the same</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>272</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // to be considered equal.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>273</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  //</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>274</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // The maximum error of a single floating-point operation is 0.5</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>275</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // units in the last place.  On Intel CPU's, all floating-point</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>276</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // calculations are done with 80-bit precision, while double has 64</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>277</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // bits.  Therefore, 4 should be enough for ordinary use.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>278</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  //</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>279</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // See the following article for more details on ULP:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>280</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>281</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  static const size_t kMaxUlps = 4;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>282</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>283</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Constructs a FloatingPoint from a raw floating-point number.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>284</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  //</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>285</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // On an Intel CPU, passing a non-normalized NAN (Not a Number)</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>286</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // around may change its bits, although the new value is guaranteed</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>287</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // to be also a NAN.  Therefore, don't expect this constructor to</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>288</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // preserve the bits in x when x is a NAN.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>289</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  explicit FloatingPoint(const RawType&amp; x) { u_.value_ = x; }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>290</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>291</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Static methods</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>292</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>293</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Reinterprets a bit pattern as a floating-point number.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>294</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  //</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>295</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // This function is needed to test the AlmostEquals() method.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>296</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  static RawType ReinterpretBits(const Bits bits) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>297</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    FloatingPoint fp(0);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>298</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    fp.u_.bits_ = bits;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>299</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    return fp.u_.value_;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>300</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>301</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>302</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Returns the floating-point number that represent positive infinity.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>303</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  static RawType Infinity() {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>304</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    return ReinterpretBits(kExponentBitMask);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>305</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>306</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>307</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Returns the maximum representable finite floating-point number.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>308</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  static RawType Max();</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>309</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>310</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Non-static methods</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>311</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>312</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Returns the bits that represents this number.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>313</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  const Bits &amp;bits() const { return u_.bits_; }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>314</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>315</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Returns the exponent bits of this number.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>316</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  Bits exponent_bits() const { return kExponentBitMask &amp; u_.bits_; }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>317</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>318</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Returns the fraction bits of this number.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>319</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  Bits fraction_bits() const { return kFractionBitMask &amp; u_.bits_; }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>320</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>321</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Returns the sign bit of this number.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>322</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  Bits sign_bit() const { return kSignBitMask &amp; u_.bits_; }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>323</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>324</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Returns true iff this is NAN (not a number).</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>325</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  bool is_nan() const {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>326</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    // It's a NAN if the exponent bits are all ones and the fraction</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>327</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    // bits are not entirely zeros.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>328</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    return (exponent_bits() == kExponentBitMask) &amp;&amp; (fraction_bits() != 0);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>329</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>330</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>331</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Returns true iff this number is at most kMaxUlps ULP's away from</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>332</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // rhs.  In particular, this function:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>333</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  //</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>334</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  //   - returns false if either number is (or both are) NAN.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>335</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  //   - treats really large numbers as almost equal to infinity.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>336</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  //   - thinks +0.0 and -0.0 are 0 DLP's apart.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>337</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  bool AlmostEquals(const FloatingPoint&amp; rhs) const {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>338</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    // The IEEE standard says that any comparison operation involving</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>339</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    // a NAN must return false.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>340</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    if (is_nan() || rhs.is_nan()) return false;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>341</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>342</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    return DistanceBetweenSignAndMagnitudeNumbers(u_.bits_, rhs.u_.bits_)</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>343</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>        &lt;= kMaxUlps;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>344</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>345</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>346</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre> private:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>347</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // The data type used to store the actual floating-point number.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>348</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  union FloatingPointUnion {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>349</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    RawType value_;  // The raw floating-point number.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>350</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    Bits bits_;      // The bits that represent the number.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>351</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  };</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>352</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>353</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Converts an integer from the sign-and-magnitude representation to</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>354</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // the biased representation.  More precisely, let N be 2 to the</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>355</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // power of (kBitCount - 1), an integer x is represented by the</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>356</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // unsigned number x + N.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>357</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  //</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>358</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // For instance,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>359</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  //</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>360</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  //   -N + 1 (the most negative number representable using</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>361</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  //          sign-and-magnitude) is represented by 1;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>362</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  //   0      is represented by N; and</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>363</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  //   N - 1  (the biggest number representable using</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>364</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  //          sign-and-magnitude) is represented by 2N - 1.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>365</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  //</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>366</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Read http://en.wikipedia.org/wiki/Signed_number_representations</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>367</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // for more details on signed number representations.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>368</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  static Bits SignAndMagnitudeToBiased(const Bits &amp;sam) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>369</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    if (kSignBitMask &amp; sam) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>370</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      // sam represents a negative number.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>371</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      return ~sam + 1;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>372</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    } else {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>373</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      // sam represents a positive number.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>374</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      return kSignBitMask | sam;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>375</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>376</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>377</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>378</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Given two numbers in the sign-and-magnitude representation,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>379</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // returns the distance between them as an unsigned number.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>380</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  static Bits DistanceBetweenSignAndMagnitudeNumbers(const Bits &amp;sam1,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>381</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                                                     const Bits &amp;sam2) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>382</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    const Bits biased1 = SignAndMagnitudeToBiased(sam1);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>383</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    const Bits biased2 = SignAndMagnitudeToBiased(sam2);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>384</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    return (biased1 &gt;= biased2) ? (biased1 - biased2) : (biased2 - biased1);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>385</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>386</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>387</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  FloatingPointUnion u_;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>388</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>};</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>389</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>390</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// We cannot use std::numeric_limits&lt;T&gt;::max() as it clashes with the max()</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>391</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// macro defined by &lt;windows.h&gt;.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>392</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>393</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>inline float FloatingPoint&lt;float&gt;::Max() { return FLT_MAX; }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>394</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>395</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>inline double FloatingPoint&lt;double&gt;::Max() { return DBL_MAX; }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>396</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>397</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Typedefs the instances of the FloatingPoint template class that we</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>398</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// care to use.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>399</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>typedef FloatingPoint&lt;float&gt; Float;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>400</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>typedef FloatingPoint&lt;double&gt; Double;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>401</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>402</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// In order to catch the mistake of putting tests that use different</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>403</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// test fixture classes in the same test case, we need to assign</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>404</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// unique IDs to fixture classes and compare them.  The TypeId type is</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>405</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// used to hold such IDs.  The user should treat TypeId as an opaque</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>406</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// type: the only operation allowed on TypeId values is to compare</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>407</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// them for equality using the == operator.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>408</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>typedef const void* TypeId;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>409</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>410</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename T&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>411</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>class TypeIdHelper {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>412</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre> public:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>413</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // dummy_ must not have a const type.  Otherwise an overly eager</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>414</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // compiler (e.g. MSVC 7.1 &amp; 8.0) may try to merge</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>415</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // TypeIdHelper&lt;T&gt;::dummy_ for different Ts as an "optimization".</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>416</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  static bool dummy_;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>417</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>};</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>418</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>419</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename T&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>420</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>bool TypeIdHelper&lt;T&gt;::dummy_ = false;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>421</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>422</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// GetTypeId&lt;T&gt;() returns the ID of type T.  Different values will be</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>423</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// returned for different types.  Calling the function twice with the</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>424</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// same type argument is guaranteed to return the same ID.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>425</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename T&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>426</pre></td>
    <td align="right" class="linecount coveredLine"><pre>1</pre></td>
    <td align="left" class="src coveredLine"><pre>TypeId GetTypeId() {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>427</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // The compiler is required to allocate a different</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>428</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // TypeIdHelper&lt;T&gt;::dummy_ variable for each T used to instantiate</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>429</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // the template.  Therefore, the address of dummy_ is guaranteed to</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>430</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // be unique.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>431</pre></td>
    <td align="right" class="linecount coveredLine"><pre>1</pre></td>
    <td align="left" class="src coveredLine"><pre>  return &amp;(TypeIdHelper&lt;T&gt;::dummy_);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>432</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>}</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>433</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>434</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Returns the type ID of ::testing::Test.  Always call this instead</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>435</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// of GetTypeId&lt; ::testing::Test&gt;() to get the type ID of</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>436</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// ::testing::Test, as the latter may give the wrong result due to a</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>437</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// suspected linker bug when compiling Google Test as a Mac OS X</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>438</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// framework.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>439</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>GTEST_API_ TypeId GetTestTypeId();</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>440</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>441</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Defines the abstract factory interface that creates instances</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>442</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// of a Test object.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>443</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>class TestFactoryBase {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>444</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre> public:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>445</pre></td>
    <td align="right" class="linecount uncoveredLine"><pre></pre></td>
    <td align="left" class="src uncoveredLine"><pre>  virtual ~TestFactoryBase() {}</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>446</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>447</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Creates a test instance to run. The instance is both created and destroyed</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>448</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // within TestInfoImpl::Run()</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>449</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  virtual Test* CreateTest() = 0;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>450</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>451</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre> protected:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>452</pre></td>
    <td align="right" class="linecount coveredLine"><pre>1</pre></td>
    <td align="left" class="src coveredLine"><pre>  TestFactoryBase() {}</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>453</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>454</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre> private:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>455</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestFactoryBase);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>456</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>};</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>457</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>458</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// This class provides implementation of TeastFactoryBase interface.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>459</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// It is used in TEST and TEST_F macros.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>460</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;class TestClass&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>461</pre></td>
    <td align="right" class="linecount coveredLine"><pre>1</pre></td>
    <td align="left" class="src coveredLine"><pre>class TestFactoryImpl : public TestFactoryBase {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>462</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre> public:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>463</pre></td>
    <td align="right" class="linecount coveredLine"><pre>1</pre></td>
    <td align="left" class="src coveredLine"><pre>  virtual Test* CreateTest() { return new TestClass; }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>464</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>};</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>465</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>466</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#if GTEST_OS_WINDOWS</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>467</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>468</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Predicate-formatters for implementing the HRESULT checking macros</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>469</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// {ASSERT|EXPECT}_HRESULT_{SUCCEEDED|FAILED}</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>470</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// We pass a long instead of HRESULT to avoid causing an</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>471</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// include dependency for the HRESULT type.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>472</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>GTEST_API_ AssertionResult IsHRESULTSuccess(const char* expr,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>473</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                                            long hr);  // NOLINT</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>474</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>GTEST_API_ AssertionResult IsHRESULTFailure(const char* expr,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>475</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                                            long hr);  // NOLINT</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>476</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>477</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#endif  // GTEST_OS_WINDOWS</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>478</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>479</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Types of SetUpTestCase() and TearDownTestCase() functions.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>480</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>typedef void (*SetUpTestCaseFunc)();</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>481</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>typedef void (*TearDownTestCaseFunc)();</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>482</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>483</pre></td>
    <td align="right" class="linecount coveredLine"><pre>2</pre></td>
    <td align="left" class="src coveredLine"><pre>struct CodeLocation {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>484</pre></td>
    <td align="right" class="linecount coveredLine"><pre>1</pre></td>
    <td align="left" class="src coveredLine"><pre>  CodeLocation(const std::string&amp; a_file, int a_line)</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>485</pre></td>
    <td align="right" class="linecount coveredLine"><pre>1</pre></td>
    <td align="left" class="src coveredLine"><pre>      : file(a_file), line(a_line) {}</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>486</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>487</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  std::string file;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>488</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  int line;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>489</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>};</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>490</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>491</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Creates a new TestInfo object and registers it with Google Test;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>492</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// returns the created object.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>493</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>494</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Arguments:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>495</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>496</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//   test_case_name:   name of the test case</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>497</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//   name:             name of the test</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>498</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//   type_param        the name of the test's type parameter, or NULL if</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>499</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//                     this is not a typed or a type-parameterized test.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>500</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//   value_param       text representation of the test's value parameter,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>501</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//                     or NULL if this is not a type-parameterized test.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>502</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//   code_location:    code location where the test is defined</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>503</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//   fixture_class_id: ID of the test fixture class</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>504</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//   set_up_tc:        pointer to the function that sets up the test case</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>505</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//   tear_down_tc:     pointer to the function that tears down the test case</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>506</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//   factory:          pointer to the factory that creates a test object.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>507</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//                     The newly created TestInfo instance will assume</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>508</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//                     ownership of the factory object.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>509</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>GTEST_API_ TestInfo* MakeAndRegisterTestInfo(</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>510</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    const char* test_case_name,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>511</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    const char* name,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>512</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    const char* type_param,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>513</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    const char* value_param,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>514</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    CodeLocation code_location,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>515</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    TypeId fixture_class_id,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>516</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    SetUpTestCaseFunc set_up_tc,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>517</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    TearDownTestCaseFunc tear_down_tc,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>518</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    TestFactoryBase* factory);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>519</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>520</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// If *pstr starts with the given prefix, modifies *pstr to be right</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>521</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// past the prefix and returns true; otherwise leaves *pstr unchanged</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>522</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// and returns false.  None of pstr, *pstr, and prefix can be NULL.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>523</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>GTEST_API_ bool SkipPrefix(const char* prefix, const char** pstr);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>524</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>525</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>526</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>527</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// State of the definition of a type-parameterized test case.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>528</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>class GTEST_API_ TypedTestCasePState {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>529</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre> public:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>530</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  TypedTestCasePState() : registered_(false) {}</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>531</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>532</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Adds the given test name to defined_test_names_ and return true</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>533</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // if the test case hasn't been registered; otherwise aborts the</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>534</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // program.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>535</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  bool AddTestName(const char* file, int line, const char* case_name,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>536</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                   const char* test_name) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>537</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    if (registered_) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>538</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      fprintf(stderr, "%s Test %s must be defined before "</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>539</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>              "REGISTER_TYPED_TEST_CASE_P(%s, ...).\n",</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>540</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>              FormatFileLocation(file, line).c_str(), test_name, case_name);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>541</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      fflush(stderr);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>542</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      posix::Abort();</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>543</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>544</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    registered_tests_.insert(</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>545</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>        ::std::make_pair(test_name, CodeLocation(file, line)));</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>546</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    return true;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>547</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>548</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>549</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  bool TestExists(const std::string&amp; test_name) const {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>550</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    return registered_tests_.count(test_name) &gt; 0;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>551</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>552</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>553</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  const CodeLocation&amp; GetCodeLocation(const std::string&amp; test_name) const {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>554</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    RegisteredTestsMap::const_iterator it = registered_tests_.find(test_name);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>555</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    GTEST_CHECK_(it != registered_tests_.end());</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>556</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    return it-&gt;second;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>557</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>558</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>559</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Verifies that registered_tests match the test names in</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>560</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // defined_test_names_; returns registered_tests if successful, or</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>561</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // aborts the program otherwise.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>562</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  const char* VerifyRegisteredTestNames(</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>563</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      const char* file, int line, const char* registered_tests);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>564</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>565</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre> private:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>566</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  typedef ::std::map&lt;std::string, CodeLocation&gt; RegisteredTestsMap;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>567</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>568</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  bool registered_;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>569</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  RegisteredTestsMap registered_tests_;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>570</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>};</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>571</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>572</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Skips to the first non-space char after the first comma in 'str';</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>573</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// returns NULL if no comma is found in 'str'.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>574</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>inline const char* SkipComma(const char* str) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>575</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  const char* comma = strchr(str, ',');</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>576</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  if (comma == NULL) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>577</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    return NULL;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>578</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>579</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  while (IsSpace(*(++comma))) {}</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>580</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  return comma;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>581</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>}</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>582</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>583</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Returns the prefix of 'str' before the first comma in it; returns</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>584</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// the entire string if it contains no comma.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>585</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>inline std::string GetPrefixUntilComma(const char* str) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>586</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  const char* comma = strchr(str, ',');</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>587</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  return comma == NULL ? str : std::string(str, comma);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>588</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>}</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>589</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>590</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Splits a given string on a given delimiter, populating a given</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>591</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// vector with the fields.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>592</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>void SplitString(const ::std::string&amp; str, char delimiter,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>593</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                 ::std::vector&lt; ::std::string&gt;* dest);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>594</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>595</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// TypeParameterizedTest&lt;Fixture, TestSel, Types&gt;::Register()</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>596</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// registers a list of type-parameterized tests with Google Test.  The</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>597</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// return value is insignificant - we just need to return something</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>598</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// such that we can call this function in a namespace scope.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>599</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>600</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Implementation note: The GTEST_TEMPLATE_ macro declares a template</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>601</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// template parameter.  It's defined in gtest-type-util.h.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>602</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;GTEST_TEMPLATE_ Fixture, class TestSel, typename Types&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>603</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>class TypeParameterizedTest {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>604</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre> public:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>605</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // 'index' is the index of the test in the type list 'Types'</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>606</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // specified in INSTANTIATE_TYPED_TEST_CASE_P(Prefix, TestCase,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>607</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Types).  Valid values for 'index' are [0, N - 1] where N is the</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>608</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // length of Types.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>609</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  static bool Register(const char* prefix,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>610</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                       const CodeLocation&amp; code_location,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>611</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                       const char* case_name, const char* test_names,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>612</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                       int index) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>613</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    typedef typename Types::Head Type;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>614</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    typedef Fixture&lt;Type&gt; FixtureClass;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>615</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    typedef typename GTEST_BIND_(TestSel, Type) TestClass;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>616</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>617</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    // First, registers the first type-parameterized test in the type</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>618</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    // list.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>619</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    MakeAndRegisterTestInfo(</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>620</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>        (std::string(prefix) + (prefix[0] == '\0' ? "" : "/") + case_name + "/"</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>621</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>         + StreamableToString(index)).c_str(),</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>622</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>        StripTrailingSpaces(GetPrefixUntilComma(test_names)).c_str(),</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>623</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>        GetTypeName&lt;Type&gt;().c_str(),</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>624</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>        NULL,  // No value parameter.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>625</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>        code_location,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>626</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>        GetTypeId&lt;FixtureClass&gt;(),</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>627</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>        TestClass::SetUpTestCase,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>628</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>        TestClass::TearDownTestCase,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>629</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>        new TestFactoryImpl&lt;TestClass&gt;);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>630</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>631</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    // Next, recurses (at compile time) with the tail of the type list.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>632</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    return TypeParameterizedTest&lt;Fixture, TestSel, typename Types::Tail&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>633</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>        ::Register(prefix, code_location, case_name, test_names, index + 1);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>634</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>635</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>};</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>636</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>637</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// The base case for the compile time recursion.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>638</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;GTEST_TEMPLATE_ Fixture, class TestSel&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>639</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>class TypeParameterizedTest&lt;Fixture, TestSel, Types0&gt; {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>640</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre> public:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>641</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  static bool Register(const char* /*prefix*/, const CodeLocation&amp;,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>642</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                       const char* /*case_name*/, const char* /*test_names*/,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>643</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                       int /*index*/) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>644</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    return true;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>645</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>646</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>};</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>647</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>648</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// TypeParameterizedTestCase&lt;Fixture, Tests, Types&gt;::Register()</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>649</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// registers *all combinations* of 'Tests' and 'Types' with Google</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>650</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Test.  The return value is insignificant - we just need to return</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>651</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// something such that we can call this function in a namespace scope.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>652</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;GTEST_TEMPLATE_ Fixture, typename Tests, typename Types&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>653</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>class TypeParameterizedTestCase {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>654</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre> public:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>655</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  static bool Register(const char* prefix, CodeLocation code_location,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>656</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                       const TypedTestCasePState* state,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>657</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                       const char* case_name, const char* test_names) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>658</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    std::string test_name = StripTrailingSpaces(</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>659</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>        GetPrefixUntilComma(test_names));</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>660</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    if (!state-&gt;TestExists(test_name)) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>661</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      fprintf(stderr, "Failed to get code location for test %s.%s at %s.",</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>662</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>              case_name, test_name.c_str(),</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>663</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>              FormatFileLocation(code_location.file.c_str(),</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>664</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                                 code_location.line).c_str());</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>665</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      fflush(stderr);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>666</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      posix::Abort();</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>667</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>668</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    const CodeLocation&amp; test_location = state-&gt;GetCodeLocation(test_name);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>669</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>670</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    typedef typename Tests::Head Head;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>671</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>672</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    // First, register the first test in 'Test' for each type in 'Types'.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>673</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    TypeParameterizedTest&lt;Fixture, Head, Types&gt;::Register(</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>674</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>        prefix, test_location, case_name, test_names, 0);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>675</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>676</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    // Next, recurses (at compile time) with the tail of the test list.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>677</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    return TypeParameterizedTestCase&lt;Fixture, typename Tests::Tail, Types&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>678</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>        ::Register(prefix, code_location, state,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>679</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                   case_name, SkipComma(test_names));</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>680</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>681</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>};</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>682</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>683</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// The base case for the compile time recursion.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>684</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;GTEST_TEMPLATE_ Fixture, typename Types&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>685</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>class TypeParameterizedTestCase&lt;Fixture, Templates0, Types&gt; {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>686</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre> public:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>687</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  static bool Register(const char* /*prefix*/, const CodeLocation&amp;,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>688</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                       const TypedTestCasePState* /*state*/,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>689</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                       const char* /*case_name*/, const char* /*test_names*/) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>690</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    return true;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>691</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>692</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>};</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>693</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>694</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#endif  // GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>695</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>696</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Returns the current OS stack trace as an std::string.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>697</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>698</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// The maximum number of stack frames to be included is specified by</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>699</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// the gtest_stack_trace_depth flag.  The skip_count parameter</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>700</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// specifies the number of top frames to be skipped, which doesn't</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>701</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// count against the number of frames to be included.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>702</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>703</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// For example, if Foo() calls Bar(), which in turn calls</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>704</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// GetCurrentOsStackTraceExceptTop(..., 1), Foo() will be included in</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>705</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// the trace but Bar() and GetCurrentOsStackTraceExceptTop() won't.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>706</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>GTEST_API_ std::string GetCurrentOsStackTraceExceptTop(</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>707</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    UnitTest* unit_test, int skip_count);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>708</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>709</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Helpers for suppressing warnings on unreachable code or constant</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>710</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// condition.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>711</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>712</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Always returns true.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>713</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>GTEST_API_ bool AlwaysTrue();</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>714</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>715</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Always returns false.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>716</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>inline bool AlwaysFalse() { return !AlwaysTrue(); }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>717</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>718</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Helper for suppressing false warning from Clang on a const char*</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>719</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// variable declared in a conditional expression always being NULL in</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>720</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// the else branch.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>721</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>struct GTEST_API_ ConstCharPtr {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>722</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  ConstCharPtr(const char* str) : value(str) {}</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>723</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  operator bool() const { return true; }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>724</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  const char* value;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>725</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>};</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>726</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>727</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// A simple Linear Congruential Generator for generating random</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>728</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// numbers with a uniform distribution.  Unlike rand() and srand(), it</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>729</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// doesn't use global state (and therefore can't interfere with user</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>730</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// code).  Unlike rand_r(), it's portable.  An LCG isn't very random,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>731</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// but it's good enough for our purposes.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>732</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>class GTEST_API_ Random {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>733</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre> public:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>734</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  static const UInt32 kMaxRange = 1u &lt;&lt; 31;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>735</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>736</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  explicit Random(UInt32 seed) : state_(seed) {}</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>737</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>738</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  void Reseed(UInt32 seed) { state_ = seed; }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>739</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>740</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Generates a random number from [0, range).  Crashes if 'range' is</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>741</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // 0 or greater than kMaxRange.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>742</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  UInt32 Generate(UInt32 range);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>743</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>744</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre> private:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>745</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  UInt32 state_;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>746</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  GTEST_DISALLOW_COPY_AND_ASSIGN_(Random);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>747</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>};</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>748</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>749</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Defining a variable of type CompileAssertTypesEqual&lt;T1, T2&gt; will cause a</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>750</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// compiler error iff T1 and T2 are different types.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>751</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename T1, typename T2&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>752</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>struct CompileAssertTypesEqual;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>753</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>754</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename T&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>755</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>struct CompileAssertTypesEqual&lt;T, T&gt; {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>756</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>};</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>757</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>758</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Removes the reference from a type if it is a reference type,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>759</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// otherwise leaves it unchanged.  This is the same as</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>760</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// tr1::remove_reference, which is not widely available yet.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>761</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename T&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>762</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>struct RemoveReference { typedef T type; };  // NOLINT</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>763</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename T&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>764</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>struct RemoveReference&lt;T&amp;&gt; { typedef T type; };  // NOLINT</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>765</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>766</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// A handy wrapper around RemoveReference that works when the argument</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>767</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// T depends on template parameters.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>768</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#define GTEST_REMOVE_REFERENCE_(T) \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>769</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    typename ::testing::internal::RemoveReference&lt;T&gt;::type</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>770</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>771</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Removes const from a type if it is a const type, otherwise leaves</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>772</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// it unchanged.  This is the same as tr1::remove_const, which is not</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>773</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// widely available yet.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>774</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename T&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>775</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>struct RemoveConst { typedef T type; };  // NOLINT</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>776</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename T&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>777</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>struct RemoveConst&lt;const T&gt; { typedef T type; };  // NOLINT</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>778</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>779</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// MSVC 8.0, Sun C++, and IBM XL C++ have a bug which causes the above</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>780</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// definition to fail to remove the const in 'const int[3]' and 'const</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>781</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// char[3][4]'.  The following specialization works around the bug.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>782</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename T, size_t N&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>783</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>struct RemoveConst&lt;const T[N]&gt; {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>784</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  typedef typename RemoveConst&lt;T&gt;::type type[N];</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>785</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>};</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>786</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>787</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1400</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>788</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// This is the only specialization that allows VC++ 7.1 to remove const in</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>789</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// 'const int[3] and 'const int[3][4]'.  However, it causes trouble with GCC</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>790</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// and thus needs to be conditionally compiled.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>791</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename T, size_t N&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>792</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>struct RemoveConst&lt;T[N]&gt; {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>793</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  typedef typename RemoveConst&lt;T&gt;::type type[N];</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>794</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>};</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>795</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#endif</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>796</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>797</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// A handy wrapper around RemoveConst that works when the argument</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>798</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// T depends on template parameters.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>799</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#define GTEST_REMOVE_CONST_(T) \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>800</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    typename ::testing::internal::RemoveConst&lt;T&gt;::type</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>801</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>802</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Turns const U&amp;, U&amp;, const U, and U all into U.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>803</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#define GTEST_REMOVE_REFERENCE_AND_CONST_(T) \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>804</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    GTEST_REMOVE_CONST_(GTEST_REMOVE_REFERENCE_(T))</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>805</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>806</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// ImplicitlyConvertible&lt;From, To&gt;::value is a compile-time bool</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>807</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// constant that's true iff type From can be implicitly converted to</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>808</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// type To.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>809</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename From, typename To&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>810</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>class ImplicitlyConvertible {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>811</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre> private:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>812</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // We need the following helper functions only for their types.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>813</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // They have no implementations.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>814</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>815</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // MakeFrom() is an expression whose type is From.  We cannot simply</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>816</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // use From(), as the type From may not have a public default</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>817</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // constructor.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>818</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  static typename AddReference&lt;From&gt;::type MakeFrom();</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>819</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>820</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // These two functions are overloaded.  Given an expression</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>821</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Helper(x), the compiler will pick the first version if x can be</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>822</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // implicitly converted to type To; otherwise it will pick the</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>823</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // second version.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>824</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  //</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>825</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // The first version returns a value of size 1, and the second</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>826</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // version returns a value of size 2.  Therefore, by checking the</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>827</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // size of Helper(x), which can be done at compile time, we can tell</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>828</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // which version of Helper() is used, and hence whether x can be</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>829</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // implicitly converted to type To.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>830</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  static char Helper(To);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>831</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  static char (&amp;Helper(...))[2];  // NOLINT</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>832</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>833</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // We have to put the 'public' section after the 'private' section,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>834</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // or MSVC refuses to compile the code.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>835</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre> public:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>836</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#if defined(__BORLANDC__)</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>837</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // C++Builder cannot use member overload resolution during template</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>838</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // instantiation.  The simplest workaround is to use its C++0x type traits</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>839</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // functions (C++Builder 2009 and above only).</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>840</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  static const bool value = __is_convertible(From, To);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>841</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#else</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>842</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // MSVC warns about implicitly converting from double to int for</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>843</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // possible loss of data, so we need to temporarily disable the</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>844</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // warning.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>845</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4244)</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>846</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  static const bool value =</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>847</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>848</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  GTEST_DISABLE_MSC_WARNINGS_POP_()</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>849</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#endif  // __BORLANDC__</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>850</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>};</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>851</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename From, typename To&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>852</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>const bool ImplicitlyConvertible&lt;From, To&gt;::value;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>853</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>854</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// IsAProtocolMessage&lt;T&gt;::value is a compile-time bool constant that's</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>855</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// true iff T is type ProtocolMessage, proto2::Message, or a subclass</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>856</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// of those.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>857</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename T&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>858</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>struct IsAProtocolMessage</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>859</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    : public bool_constant&lt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>860</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  ImplicitlyConvertible&lt;const T*, const ::ProtocolMessage*&gt;::value ||</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>861</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  ImplicitlyConvertible&lt;const T*, const ::proto2::Message*&gt;::value&gt; {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>862</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>};</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>863</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>864</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// When the compiler sees expression IsContainerTest&lt;C&gt;(0), if C is an</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>865</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// STL-style container class, the first overload of IsContainerTest</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>866</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// will be viable (since both C::iterator* and C::const_iterator* are</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>867</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// valid types and NULL can be implicitly converted to them).  It will</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>868</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// be picked over the second overload as 'int' is a perfect match for</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>869</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// the type of argument 0.  If C::iterator or C::const_iterator is not</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>870</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// a valid type, the first overload is not viable, and the second</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>871</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// overload will be picked.  Therefore, we can determine whether C is</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>872</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// a container class by checking the type of IsContainerTest&lt;C&gt;(0).</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>873</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// The value of the expression is insignificant.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>874</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>875</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Note that we look for both C::iterator and C::const_iterator.  The</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>876</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// reason is that C++ injects the name of a class as a member of the</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>877</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// class itself (e.g. you can refer to class iterator as either</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>878</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// 'iterator' or 'iterator::iterator').  If we look for C::iterator</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>879</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// only, for example, we would mistakenly think that a class named</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>880</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// iterator is an STL container.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>881</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>//</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>882</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Also note that the simpler approach of overloading</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>883</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// IsContainerTest(typename C::const_iterator*) and</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>884</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// IsContainerTest(...) doesn't work with Visual Age C++ and Sun C++.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>885</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>typedef int IsContainer;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>886</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;class C&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>887</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>IsContainer IsContainerTest(int /* dummy */,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>888</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                            typename C::iterator* /* it */ = NULL,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>889</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>                            typename C::const_iterator* /* const_it */ = NULL) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>890</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  return 0;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>891</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>}</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>892</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>893</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>typedef char IsNotContainer;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>894</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;class C&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>895</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>IsNotContainer IsContainerTest(long /* dummy */) { return '\0'; }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>896</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>897</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename C, bool =</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>898</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  sizeof(IsContainerTest&lt;C&gt;(0)) == sizeof(IsContainer)</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>899</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>900</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>struct IsRecursiveContainerImpl;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>901</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>902</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename C&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>903</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>struct IsRecursiveContainerImpl&lt;C, false&gt; : public false_type {};</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>904</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>905</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename C&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>906</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>struct IsRecursiveContainerImpl&lt;C, true&gt; {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>907</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  typedef</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>908</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    typename IteratorTraits&lt;typename C::iterator&gt;::value_type</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>909</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  value_type;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>910</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  typedef is_same&lt;value_type, C&gt; type;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>911</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>};</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>912</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>913</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// IsRecursiveContainer&lt;Type&gt; is a unary compile-time predicate that</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>914</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// evaluates whether C is a recursive container type. A recursive container</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>915</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// type is a container type whose value_type is equal to the container type</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>916</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// itself. An example for a recursive container type is</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>917</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// boost::filesystem::path, whose iterator has a value_type that is equal to</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>918</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// boost::filesystem::path.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>919</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template&lt;typename C&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>920</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>struct IsRecursiveContainer : public IsRecursiveContainerImpl&lt;C&gt;::type {};</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>921</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>922</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// EnableIf&lt;condition&gt;::type is void when 'Cond' is true, and</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>923</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// undefined when 'Cond' is false.  To use SFINAE to make a function</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>924</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// overload only apply when a particular expression is true, add</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>925</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// "typename EnableIf&lt;expression&gt;::type* = 0" as the last parameter.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>926</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template&lt;bool&gt; struct EnableIf;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>927</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template&lt;&gt; struct EnableIf&lt;true&gt; { typedef void type; };  // NOLINT</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>928</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>929</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Utilities for native arrays.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>930</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>931</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// ArrayEq() compares two k-dimensional native arrays using the</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>932</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// elements' operator==, where k can be any integer &gt;= 0.  When k is</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>933</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// 0, ArrayEq() degenerates into comparing a single pair of values.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>934</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>935</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename T, typename U&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>936</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>bool ArrayEq(const T* lhs, size_t size, const U* rhs);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>937</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>938</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// This generic version is used when k is 0.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>939</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename T, typename U&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>940</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>inline bool ArrayEq(const T&amp; lhs, const U&amp; rhs) { return lhs == rhs; }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>941</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>942</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// This overload is used when k &gt;= 1.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>943</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename T, typename U, size_t N&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>944</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>inline bool ArrayEq(const T(&amp;lhs)[N], const U(&amp;rhs)[N]) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>945</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  return internal::ArrayEq(lhs, N, rhs);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>946</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>}</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>947</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>948</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// This helper reduces code bloat.  If we instead put its logic inside</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>949</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// the previous ArrayEq() function, arrays with different sizes would</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>950</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// lead to different copies of the template code.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>951</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename T, typename U&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>952</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>bool ArrayEq(const T* lhs, size_t size, const U* rhs) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>953</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  for (size_t i = 0; i != size; i++) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>954</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    if (!internal::ArrayEq(lhs[i], rhs[i]))</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>955</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      return false;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>956</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>957</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  return true;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>958</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>}</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>959</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>960</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Finds the first element in the iterator range [begin, end) that</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>961</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// equals elem.  Element may be a native array type itself.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>962</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename Iter, typename Element&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>963</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>Iter ArrayAwareFind(Iter begin, Iter end, const Element&amp; elem) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>964</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  for (Iter it = begin; it != end; ++it) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>965</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    if (internal::ArrayEq(*it, elem))</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>966</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      return it;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>967</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>968</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  return end;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>969</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>}</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>970</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>971</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// CopyArray() copies a k-dimensional native array using the elements'</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>972</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// operator=, where k can be any integer &gt;= 0.  When k is 0,</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>973</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// CopyArray() degenerates into copying a single value.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>974</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>975</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename T, typename U&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>976</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>void CopyArray(const T* from, size_t size, U* to);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>977</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>978</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// This generic version is used when k is 0.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>979</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename T, typename U&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>980</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>inline void CopyArray(const T&amp; from, U* to) { *to = from; }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>981</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>982</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// This overload is used when k &gt;= 1.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>983</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename T, typename U, size_t N&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>984</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>inline void CopyArray(const T(&amp;from)[N], U(*to)[N]) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>985</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  internal::CopyArray(from, N, *to);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>986</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>}</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>987</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>988</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// This helper reduces code bloat.  If we instead put its logic inside</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>989</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// the previous CopyArray() function, arrays with different sizes</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>990</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// would lead to different copies of the template code.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>991</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename T, typename U&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>992</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>void CopyArray(const T* from, size_t size, U* to) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>993</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  for (size_t i = 0; i != size; i++) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>994</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    internal::CopyArray(from[i], to + i);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>995</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>996</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>}</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>997</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>998</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// The relation between an NativeArray object (see below) and the</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>999</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// native array it represents.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1000</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// We use 2 different structs to allow non-copyable types to be used, as long</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1001</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// as RelationToSourceReference() is passed.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1002</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>struct RelationToSourceReference {};</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1003</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>struct RelationToSourceCopy {};</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1004</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1005</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Adapts a native array to a read-only STL-style container.  Instead</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1006</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// of the complete STL container concept, this adaptor only implements</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1007</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// members useful for Google Mock's container matchers.  New members</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1008</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// should be added as needed.  To simplify the implementation, we only</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1009</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// support Element being a raw type (i.e. having no top-level const or</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1010</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// reference modifier).  It's the client's responsibility to satisfy</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1011</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// this requirement.  Element can be an array type itself (hence</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1012</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// multi-dimensional arrays are supported).</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1013</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>template &lt;typename Element&gt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1014</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>class NativeArray {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1015</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre> public:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1016</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // STL-style container typedefs.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1017</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  typedef Element value_type;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1018</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  typedef Element* iterator;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1019</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  typedef const Element* const_iterator;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1020</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1021</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Constructs from a native array. References the source.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1022</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  NativeArray(const Element* array, size_t count, RelationToSourceReference) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1023</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    InitRef(array, count);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1024</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1025</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1026</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Constructs from a native array. Copies the source.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1027</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  NativeArray(const Element* array, size_t count, RelationToSourceCopy) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1028</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    InitCopy(array, count);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1029</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1030</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1031</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Copy constructor.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1032</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  NativeArray(const NativeArray&amp; rhs) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1033</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    (this-&gt;*rhs.clone_)(rhs.array_, rhs.size_);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1034</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1035</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1036</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  ~NativeArray() {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1037</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    if (clone_ != &amp;NativeArray::InitRef)</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1038</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      delete[] array_;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1039</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1040</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1041</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // STL-style container methods.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1042</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  size_t size() const { return size_; }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1043</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  const_iterator begin() const { return array_; }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1044</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  const_iterator end() const { return array_ + size_; }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1045</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  bool operator==(const NativeArray&amp; rhs) const {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1046</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    return size() == rhs.size() &amp;&amp;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1047</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>        ArrayEq(begin(), size(), rhs.begin());</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1048</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1049</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1050</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre> private:</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1051</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  enum {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1052</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    kCheckTypeIsNotConstOrAReference = StaticAssertTypeEqHelper&lt;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1053</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>        Element, GTEST_REMOVE_REFERENCE_AND_CONST_(Element)&gt;::value</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1054</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  };</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1055</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1056</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Initializes this object with a copy of the input.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1057</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  void InitCopy(const Element* array, size_t a_size) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1058</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    Element* const copy = new Element[a_size];</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1059</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    CopyArray(array, a_size, copy);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1060</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    array_ = copy;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1061</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    size_ = a_size;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1062</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    clone_ = &amp;NativeArray::InitCopy;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1063</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1064</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1065</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  // Initializes this object with a reference of the input.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1066</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  void InitRef(const Element* array, size_t a_size) {</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1067</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    array_ = array;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1068</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    size_ = a_size;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1069</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    clone_ = &amp;NativeArray::InitRef;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1070</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1071</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1072</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  const Element* array_;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1073</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  size_t size_;</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1074</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  void (NativeArray::*clone_)(const Element*, size_t);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1075</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1076</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  GTEST_DISALLOW_ASSIGN_(NativeArray);</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1077</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>};</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1078</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1079</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>}  // namespace internal</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1080</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>}  // namespace testing</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1081</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1082</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#define GTEST_MESSAGE_AT_(file, line, message, result_type) \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1083</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  ::testing::internal::AssertHelper(result_type, file, line, message) \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1084</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    = ::testing::Message()</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1085</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1086</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#define GTEST_MESSAGE_(message, result_type) \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1087</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  GTEST_MESSAGE_AT_(__FILE__, __LINE__, message, result_type)</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1088</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1089</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#define GTEST_FATAL_FAILURE_(message) \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1090</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  return GTEST_MESSAGE_(message, ::testing::TestPartResult::kFatalFailure)</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1091</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1092</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#define GTEST_NONFATAL_FAILURE_(message) \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1093</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  GTEST_MESSAGE_(message, ::testing::TestPartResult::kNonFatalFailure)</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1094</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1095</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#define GTEST_SUCCESS_(message) \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1096</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  GTEST_MESSAGE_(message, ::testing::TestPartResult::kSuccess)</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1097</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1098</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Suppresses MSVC warnings 4072 (unreachable code) for the code following</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1099</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// statement if it returns or throws (or doesn't return or throw in some</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1100</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// situations).</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1101</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#define GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement) \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1102</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  if (::testing::internal::AlwaysTrue()) { statement; }</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1103</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1104</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#define GTEST_TEST_THROW_(statement, expected_exception, fail) \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1105</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1106</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  if (::testing::internal::ConstCharPtr gtest_msg = "") { \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1107</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    bool gtest_caught_expected = false; \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1108</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    try { \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1109</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1110</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    } \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1111</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    catch (expected_exception const&amp;) { \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1112</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      gtest_caught_expected = true; \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1113</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    } \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1114</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    catch (...) { \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1115</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      gtest_msg.value = \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1116</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>          "Expected: " #statement " throws an exception of type " \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1117</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>          #expected_exception ".\n  Actual: it throws a different type."; \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1118</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1119</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    } \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1120</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    if (!gtest_caught_expected) { \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1121</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      gtest_msg.value = \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1122</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>          "Expected: " #statement " throws an exception of type " \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1123</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>          #expected_exception ".\n  Actual: it throws nothing."; \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1124</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1125</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    } \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1126</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  } else \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1127</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__): \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1128</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      fail(gtest_msg.value)</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1129</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1130</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#define GTEST_TEST_NO_THROW_(statement, fail) \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1131</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1132</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  if (::testing::internal::AlwaysTrue()) { \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1133</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    try { \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1134</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1135</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    } \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1136</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    catch (...) { \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1137</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__); \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1138</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    } \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1139</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  } else \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1140</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__): \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1141</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      fail("Expected: " #statement " doesn't throw an exception.\n" \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1142</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>           "  Actual: it throws.")</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1143</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1144</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#define GTEST_TEST_ANY_THROW_(statement, fail) \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1145</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1146</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  if (::testing::internal::AlwaysTrue()) { \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1147</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    bool gtest_caught_any = false; \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1148</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    try { \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1149</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1150</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    } \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1151</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    catch (...) { \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1152</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      gtest_caught_any = true; \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1153</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    } \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1154</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    if (!gtest_caught_any) { \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1155</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      goto GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__); \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1156</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    } \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1157</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  } else \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1158</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__): \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1159</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      fail("Expected: " #statement " throws an exception.\n" \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1160</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>           "  Actual: it doesn't.")</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1161</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1162</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1163</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Implements Boolean test assertions such as EXPECT_TRUE. expression can be</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1164</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// either a boolean expression or an AssertionResult. text is a textual</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1165</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// represenation of expression as it was passed into the EXPECT_TRUE.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1166</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#define GTEST_TEST_BOOLEAN_(expression, text, actual, expected, fail) \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1167</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1168</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  if (const ::testing::AssertionResult gtest_ar_ = \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1169</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      ::testing::AssertionResult(expression)) \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1170</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    ; \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1171</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  else \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1172</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    fail(::testing::internal::GetBoolAssertionFailureMessage(\</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1173</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>        gtest_ar_, text, #actual, #expected).c_str())</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1174</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1175</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#define GTEST_TEST_NO_FATAL_FAILURE_(statement, fail) \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1176</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1177</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  if (::testing::internal::AlwaysTrue()) { \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1178</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    ::testing::internal::HasNewFatalFailureHelper gtest_fatal_failure_checker; \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1179</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1180</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    if (gtest_fatal_failure_checker.has_new_fatal_failure()) { \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1181</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      goto GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__); \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1182</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    } \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1183</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  } else \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1184</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__): \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1185</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      fail("Expected: " #statement " doesn't generate new fatal " \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1186</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>           "failures in the current thread.\n" \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1187</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>           "  Actual: it does.")</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1188</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1189</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Expands to the name of the class that implements the given test.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1190</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1191</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  test_case_name##_##test_name##_Test</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1192</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1193</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>// Helper macro for defining tests.</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1194</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#define GTEST_TEST_(test_case_name, test_name, parent_class, parent_id)\</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1195</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class {\</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1196</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre> public:\</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1197</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {}\</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1198</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre> private:\</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1199</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  virtual void TestBody();\</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1200</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;\</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1201</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  GTEST_DISALLOW_COPY_AND_ASSIGN_(\</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1202</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>      GTEST_TEST_CLASS_NAME_(test_case_name, test_name));\</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1203</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>};\</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1204</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>\</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1205</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_case_name, test_name)\</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1206</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>  ::test_info_ =\</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1207</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>    ::testing::internal::MakeAndRegisterTestInfo(\</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1208</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>        #test_case_name, #test_name, NULL, NULL, \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1209</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>        ::testing::internal::CodeLocation(__FILE__, __LINE__), \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1210</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>        (parent_id), \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1211</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>        parent_class::SetUpTestCase, \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1212</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>        parent_class::TearDownTestCase, \</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1213</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>        new ::testing::internal::TestFactoryImpl&lt;\</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1214</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>            GTEST_TEST_CLASS_NAME_(test_case_name, test_name)&gt;);\</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1215</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1216</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1217</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre>#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_</pre></td>
    </tr>

    <tr>
    <td align="right" class="lineno"><pre>1218</pre></td>
    <td align="right" class="linecount "><pre></pre></td>
    <td align="left" class="src "><pre></pre></td>
    </tr>

  </table>
  <br>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr><td class="hr"><td></tr>
    <tr><td class="footer">Generated by: <a href="http://gcovr.com">GCOVR (Version 3.2)</a></td></tr>
  </table>
  <br>

</body>

</html>

