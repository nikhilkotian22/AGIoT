/*
 * Agora Digital Solutions Inc.
 *************************************************************************************
 * Copyright 2020 Agora Digital Solutions Inc.

 * All rights reserved in Agora Digital Solutions Inc. authored and generated code (including the selection and arrangement of the source code base regardless of the authorship of individual files), but not including any copyright interest(s) owned by a third party related to source code or object code authored or generated by non- Agora Digital Solutions Inc. personnel.
 * Any use, disclosure and/or reproduction of source code is prohibited unless in compliance with the AGORA SOFTWARE DEVELOPMENT KIT LICENSE AGREEMENT.
 *
 */

#include <cmath>
#include "flow_velocity.hpp"
#include "Utils.hpp"

FlowVelocity::FlowVelocity(){

    pipeDiameter = 3.5;
    pipeCrossSecArea = 2*M_PI*pow(((pipeDiameter)/2), 2);

    oilFlow   = { 0, 1, 0};
    gasFlow   = { 0, 1, 0};
    waterFlow = { 0, 1, 0};
    valveProfile1 = { 0, 1, 0};
    valveProfile2 = { 0, 1, 0};

    oilVelocity   = { 0, 1, 0};
    gasVelocity   = { 0, 1, 0};
    waterVelocity = { 0, 1, 0};
    valveProfile  = { 0, 1, 0};

    valve_position = 100;
}

FlowVelocity::~FlowVelocity(){

}

int FlowVelocity::Configure(hbm::JSerializer * config_serializer){

    LOG_DEBUG << "New Config";

    config_serializer->GetValue("PipeDiameter", pipeDiameter);

    LOG_DEBUG << "pipeDiameter: " << pipeDiameter;

    pipeCrossSecArea = 2*M_PI*pow(((pipeDiameter)/2), 2);

    return 0;
}

int FlowVelocity::Start(){

    start_thread();

    m_Run = true;

    return 0;
}

int FlowVelocity::Stop(){

    exit_thread();

    m_Run = false;

    return 0;
}
	
int FlowVelocity::Process(){

    return 0;

}

int FlowVelocity::HandleData(hbm::JSerializer * data_serializer){

    std::string io_data;

    data_serializer->GetAll(io_data, 4);

    LOG_DEBUG << "New IO Data: \n" << io_data;

    data_serializer->GetIOValue( "1", "qo_lc", oilFlow );
    data_serializer->GetIOValue( "1", "qg_lc", gasFlow );
    data_serializer->GetIOValue( "1", "qw_lc", waterFlow );

    data_serializer->GetIOValue( "1", "valve_profile1", valveProfile1 );
    data_serializer->GetIOValue( "1", "valve_profile2", valveProfile2 );
    int ret_val = data_serializer->GetIOValue( "256", "valve_profile", valveProfile );

    if ( ret_val == 0 )
    {
        profile_vec.clear();
        if  ( Utils::Base64Decode( valveProfile.value_str, profile_vec ) )
        {
            LOG_DEBUG << "Processing Vector IO : profile, num decoded bytes: " << profile_vec.size();

            for (int j = 0; j<profile_vec.size(); j++)
            {
                LOG_DEBUG << "RX valve_profil[" << j <<"] = " << profile_vec[j]; 
            }
        }
        else
        {
            LOG_ERROR << "Failed to process Vector IO";
        }

    }

    return 0;
}

void FlowVelocity::thread_run(){

    std::string data_out;

    set_thread_name( "Algorithm_vFlow" );

    block_signals();


    struct timeval tvCurrent;

    //Setup the non-changing header paramters
    hbm::MSG_HEADER_T header;

    header.msg_type = "IODataReport";
    header.group_id ="EDGE";
    header.landing_point = hbm::LandingPointEDGE;
    header.config_version = 1;

    m_DataOutSerializer.Clear();

    uint32_t oflow_quality, gflow_quality, wflow_quality;

    while ( m_Run )
	{
        m_Signal->TimedWait( m_Period ); 

        Utils::GetRealtimeClock( tvCurrent );

        if (--valve_position < 50)
        {
            valve_position = 100;
        }

        if ( Utils::IsGoodStatusCode( (hbm::opcUA::StatusCode) oilFlow.quality_code) )
        {
            oflow_quality = (uint32_t) hbm::opcUA::StatusCode::Good;
        }
        else
        {
            oflow_quality = (uint32_t) hbm::opcUA::StatusCode::BadAggregateInvalidInputs;
        }

        if ( Utils::IsGoodStatusCode( (hbm::opcUA::StatusCode) gasFlow.quality_code) )
        {
            gflow_quality = (uint32_t) hbm::opcUA::StatusCode::Good;
        }
        else
        {
            gflow_quality = (uint32_t) hbm::opcUA::StatusCode::BadAggregateInvalidInputs;
        }

        if ( Utils::IsGoodStatusCode( (hbm::opcUA::StatusCode) waterFlow.quality_code) )
        {
            wflow_quality = (uint32_t) hbm::opcUA::StatusCode::Good;
        }
        else
        {
            wflow_quality = (uint32_t) hbm::opcUA::StatusCode::BadAggregateInvalidInputs;
        }
        

        oilVelocity   = { (double) oilFlow.value / pipeCrossSecArea, oflow_quality, tvCurrent.tv_sec};
        gasVelocity   = { (double) gasFlow.value / pipeCrossSecArea, gflow_quality, tvCurrent.tv_sec};
        waterVelocity = { (double) waterFlow.value / pipeCrossSecArea, wflow_quality, tvCurrent.tv_sec};
        valvePosition = { (double) valve_position, 0, tvCurrent.tv_sec};

        profile1_vec.clear();
        if  ( Utils::Base64Decode( valveProfile1.value_str, profile1_vec ) )
        {
            LOG_DEBUG << "Processing Vector IO : profile1, num decoded bytes: " << profile1_vec.size();

            for (int j = 0; j<profile1_vec.size(); j++)
            {
                LOG_DEBUG << "valve_profil1[" << j <<"] = " << profile1_vec[j]; 
            }
        }
        else
        {
            LOG_ERROR << "Failed to process Vector IO: profile1";
        }

        profile2_vec.clear();
        if  ( Utils::Base64Decode( valveProfile2.value_str, profile2_vec ) )
        {
            LOG_DEBUG << "Processing Vector IO: profile2, num decoded bytes: " << profile2_vec.size();

            for (int j = 0; j<profile2_vec.size(); j++)
            {
                LOG_DEBUG << "valve_profil1[" << j <<"] = " << profile2_vec[j]; 
            }
        }
        else
        {
            LOG_ERROR << "Failed to process Vector IO: profile2";
        }
    
        profile_vec.clear();
        profile_vec = profile1_vec;
        profile_vec.insert( profile_vec.end(), profile2_vec.begin(), profile2_vec.end() );
        Utils::Base64Encode( profile_vec, valveProfile.value_str );

        valveProfile.quality_code = valveProfile1.quality_code | valveProfile2.quality_code;
        valveProfile.timestamp = tvCurrent.tv_sec;

        m_DataOutSerializer.CacheIOValue("256", "oil-velocity", oilVelocity);
        m_DataOutSerializer.CacheIOValue("256", "gas-velocity", gasVelocity);
        m_DataOutSerializer.CacheIOValue("256", "water-velocity", waterVelocity);
        m_DataOutSerializer.CacheIOValue("1", "valve_pos", valvePosition);
        m_DataOutSerializer.CacheIOValue("256", "valve_profile", valveProfile);

        m_DataOutSerializer.SerializeCachedIOs();

        header.message_id = rand();
        header.timestamp = Utils::GetMonotonicClock_us();
        m_DataOutSerializer.SetMsgHeader(header);

        std::string timestamp; 
        Utils::GetRealtimeClockStr(timestamp);
        m_DataOutSerializer.SetValue("timestamp", timestamp);

        m_DataOutSerializer.GetAll(data_out, 4); 

        LOG_DEBUG << "Flow Velocity Computed Data: \n" << data_out;

        if (NULL != m_BusClient)
        {
            m_BusClient->SendMessage(m_DataOutEndpoint, data_out);
        }    
    }

}
